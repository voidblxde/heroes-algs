# Heroes — algorithms

Репозиторий содержит реализацию 4 алгоритмов для пошаговой стратегии Heroes:
- генерация армии компьютера (`generate`);
- симуляция боя (`simulate`);
- выбор доступных целей для атаки (`getSuitableUnits`);
- поиск кратчайшего пути на поле (`getTargetPath`).

Проект собирается в JAR, который подхватывается игрой из папки `heroes/jars` как `obf.jar`.

---

## Структура

Ключевые файлы находятся в модуле задания:

- `src/programs/GeneratePresetImpl.java`
- `src/programs/SimulateBattleImpl.java`
- `src/programs/SuitableForAttackUnitsFinderImpl.java`
- `src/programs/UnitTargetPathFinderImpl.java`

Зависимости и интерфейсы предоставляет библиотека `heroes_task_lib` (подключена в проекте).

---

## Реализованные алгоритмы

### 1) GeneratePresetImpl — `Army generate(List<Unit> unitList, int maxPoints)`

**Цель:** сформировать армию компьютера с ограничениями:
- суммарная стоимость ≤ `maxPoints`;
- ≤ 11 юнитов каждого типа;
- приоритет эффективности: сначала максимизируем `baseAttack / cost`, затем `health / cost`.

**Алгоритм:**
1. Берём по одному шаблону на каждый тип юнита из `unitList`.
2. Сортируем типы по ключу:
    - `attackPerCost = baseAttack / cost` (убывание),
    - `healthPerCost = health / cost` (убывание),
    - tie-break: меньшая стоимость.
3. Набираем армию жадно “по кругу” типов:
    - на каждом шаге выбираем первый тип (по приоритету), который:
        - не превысил лимит 11 для данного типа,
        - помещается в бюджет `maxPoints`.
    - создаём новый объект `Unit` по шаблону.
4. Возвращаем `Army`, выставляя `points`.

**Сложность:**
- пусть `T` — число типов юнитов (в текущей версии `T=4`),
- `U` — максимум юнитов в армии (`U ≤ 44 = 4*11`).

Этапы:
- подготовка шаблонов: `O(T)`
- сортировка типов: `O(T log T)`
- цикл набора: максимум `U` итераций, внутри перебор до `T` типов ⇒ `O(U*T)`

Итог: `O(T log T + U*T) ≈ O(U*T)`  
Требование выполняется (не хуже `O(U*T)`).

---

### 2) SimulateBattleImpl — `void simulate(Army playerArmy, Army computerArmy)`

**Цель:** смоделировать бой по раундам:
- каждый раунд: сортировка живых юнитов по убыванию атаки;
- по очереди выполняются ходы;
- юнит атакует через `unit.getProgram().attack()` (может вернуть `null`);
- после каждого хода вызывается лог `printBattleLog.printBattleLog(attacker, target)`;
- бой завершается, когда у одной из армий не осталось живых юнитов.

**Алгоритм (по раундам):**
1. Пока в обеих армиях есть живые юниты:
    - собираем список всех живых юнитов обеих армий;
    - сортируем по `baseAttack` по убыванию;
    - идём по списку: если юнит жив — делает ход (`attack()`), печатаем лог;
2. Если в процессе раунда одна армия закончилась — симуляция завершается.

**Сложность:**
Пусть `N` — число живых юнитов в текущем раунде.
- построение списка: `O(N)`
- сортировка: `O(N log N)`
- проход по очереди: `O(N)` (при допущении `attack()` за `O(1)` по условию)

Итого на раунд: `O(N log N)`  
Общая сложность боя — сумма по раундам, требование выполняется.

---

### 3) SuitableForAttackUnitsFinderImpl —
`List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)`

**Цель:** вернуть только те цели, которые “открыты” для атаки, чтобы не делать лишний поиск пути.

Условия:
- если атакуется правая армия (игрок), цель подходит если **не закрыта справа** по `y`
- если атакуется левая армия (компьютер), цель подходит если **не закрыта слева** по `y`

**Алгоритм:**
Для каждого ряда:
1. Собираем `Set` занятых координат `y` живыми юнитами.
2. Для каждого юнита проверяем наличие “прикрывающего” юнита в соседней клетке:
    - `isLeftArmyTarget == true` → проверяем `y-1`
    - `isLeftArmyTarget == false` → проверяем `y+1`
3. Если прикрытия нет — добавляем в результат.

**Сложность:**
Пусть `M` — число юнитов в ряду (рядов 3, фиксировано).
- построение `Set`: `O(M)`
- проверка юнитов: `O(M)` (операции `Set.contains` амортизированно `O(1)`)

Итог: `O(M)` на ряд, `O(N)` по всем юнитам (линейно).

---

### 4) UnitTargetPathFinderImpl —
`List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)`

**Цель:** найти кратчайший путь на сетке 27×21 с препятствиями (другие юниты). Движение по диагонали разрешено.

**Алгоритм: BFS по клеткам**
1. Строим карту занятых клеток (`blocked`), исключая атакующего и цель.
2. BFS от клетки атакующего до клетки цели по 8 направлениям (включая диагонали).
3. Восстанавливаем путь по массиву `parent` и возвращаем список `Edge` от старта до цели.
4. Если цель недостижима — возвращаем пустой список.

**Сложность:**
Поле фиксировано: `WIDTH=27`, `HEIGHT=21`.
BFS посещает каждую клетку максимум один раз:
- время: `O(W*H)`
- память: `O(W*H)`